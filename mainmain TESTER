#define MOT_A1_PIN 5
#define MOT_A2_PIN 6
#define MOT_B1_PIN 9
#define MOT_B2_PIN 10

#define UART_BAUDRATE 9600

#define UPDATE_PERIOD_MS 500

#define PWM_VALUE_MAX 255
#define PWM_VALUE_MIN -255

#define MOTOR_L_PWM_INITIAL_VALUE 180
#define MOTOR_R_PWM_INITIAL_VALUE 180

#define MOTOR_PWM_DECREMENT_VALUE 20

#define VARIABLE_SPEED_ENABLE 0


// ================================================================================
/// Configure the hardware once after booting up.  This runs once after pressing
//// reset or powering up the board.
void setup(void)
{
  // Initialize the stepper driver control pins to output drive mode.
  pinMode(MOT_A1_PIN, OUTPUT);
  pinMode(MOT_A2_PIN, OUTPUT);
  pinMode(MOT_B1_PIN, OUTPUT);
  pinMode(MOT_B2_PIN, OUTPUT);

  // Start with drivers off, motors coasting.
  digitalWrite(MOT_A1_PIN, LOW);
  digitalWrite(MOT_A2_PIN, LOW);
  digitalWrite(MOT_B1_PIN, LOW);
  digitalWrite(MOT_B2_PIN, LOW);

}
// ================================================================================
/// Set the current on a motor channel using PWM and directional logic.
/// Changing the current will affect the motor speed, but please note this is
/// not a calibrated speed control.  This function will configure the pin output
/// state and return.
///
/// \param pwm    PWM duty cycle ranging from -255 full reverse to 255 full forward
/// \param IN1_PIN  pin number xIN1 for the given channel
/// \param IN2_PIN  pin number xIN2 for the given channel

void set_motor_pwm(int pwm, int IN1_PIN, int IN2_PIN)
{
  if (pwm < 0) {  // reverse speeds
    analogWrite(IN1_PIN, -pwm);
    digitalWrite(IN2_PIN, LOW);

  } else { // stop or forward
    digitalWrite(IN1_PIN, LOW);
    analogWrite(IN2_PIN, pwm);
  }
}
// ================================================================================
/// Set the current on both motors.
///
/// \param pwm_A  motor A PWM, -255 to 255
/// \param pwm_B  motor B PWM, -255 to 255

void set_motor_currents(int pwm_A, int pwm_B)
{
  set_motor_pwm(pwm_A, MOT_A1_PIN, MOT_A2_PIN);
  set_motor_pwm(pwm_B, MOT_B1_PIN, MOT_B2_PIN);

  // Print a status message to the console.
  Serial.print("Set motor A PWM = ");
  Serial.print(pwm_A);
  Serial.print(" motor B PWM = ");
  Serial.println(pwm_B);
}

// ================================================================================
/// Simple primitive for the motion sequence to set a speed and wait for an interval.
///
/// \param pwm_A  motor A PWM, -255 to 255
/// \param pwm_B  motor B PWM, -255 to 255
/// \param duration delay in milliseconds
void spin_and_wait(int pwm_A, int pwm_B, int duration)
{
  set_motor_currents(pwm_A, pwm_B);
  delay(duration);
}

void loop()
{

  spin_and_wait(leftServoSpeed,rightServoSpeed,500); // sets speed of motors to value entered above for 0.5 sec and keeps repeating
}







#define FIRMWARE_VERSION "v1.0.0"

#define UART_BAUDRATE 9600

#define MOTOR_L1_PIN 5
#define MOTOR_L2_PIN 6
#define MOTOR_R1_PIN 9
#define MOTOR_R2_PIN 10

#define UPDATE_PERIOD_MS 500

#define PWM_VALUE_MAX 255
#define PWM_VALUE_MIN -255

#define MOTOR_L_PWM_INITIAL_VALUE 200
#define MOTOR_R_PWM_INITIAL_VALUE 200

#define MOTOR_PWM_DECREMENT_VALUE 20

#define VARIABLE_SPEED_ENABLE 0

// Compile-time check of initial PWM values
#if ((MOTOR_L_PWM_INITIAL_VALUE < PWM_VALUE_MIN) || (MOTOR_L_PWM_INITIAL_VALUE > PWM_VALUE_MAX))
  #error "MOTOR_L_PWM_INITIAL_VALUE is out of range"
#endif

#if ((MOTOR_R_PWM_INITIAL_VALUE < PWM_VALUE_MIN) || (MOTOR_R_PWM_INITIAL_VALUE > PWM_VALUE_MAX))
  #error "MOTOR_R_PWM_INITIAL_VALUE is out of range"
#endif

// Function to Set Motor Control Parameters
void SetMotorControlParameters(int PWMValue,
                               unsigned int HBridgeControlPinA,
                               unsigned int HBridgeControlPinB)
{
  if (PWMValue >= 0)
  {
    analogWrite(HBridgeControlPinB, PWMValue);
    digitalWrite(HBridgeControlPinA, LOW);
  }
  else
  {
    analogWrite(HBridgeControlPinA, -PWMValue);
    digitalWrite(HBridgeControlPinB, LOW);
  }
}

// Function to Update Motor Speed
void UpdateMotorSpeed(int LeftMotorPWMValue,
                      int RightMotorPWMValue,
                      unsigned long DurationMilliseconds)
{
  // Set Left Motor Control Parameters
  SetMotorControlParameters(LeftMotorPWMValue,
                            MOTOR_L1_PIN,
                            MOTOR_L2_PIN);
  
  // Set Right Motor Control Parameters
  SetMotorControlParameters(RightMotorPWMValue,
                            MOTOR_R1_PIN,
                            MOTOR_R2_PIN);
  
  // Add blocking delay (in ms)
  delay(DurationMilliseconds);
}

// Setup function runs once when board is powered up or reset
void setup()
{
  // Initialise UART
  Serial.begin(UART_BAUDRATE);
  
  // Initialise GPIO
  pinMode(MOTOR_L1_PIN, OUTPUT);
  pinMode(MOTOR_L2_PIN, OUTPUT);
  pinMode(MOTOR_R1_PIN, OUTPUT);
  pinMode(MOTOR_R2_PIN, OUTPUT);
  
  // Initialise Motor Driver
  digitalWrite(MOTOR_L1_PIN, LOW);
  digitalWrite(MOTOR_L2_PIN, LOW);
  digitalWrite(MOTOR_R1_PIN, LOW);
  digitalWrite(MOTOR_R2_PIN, LOW);
  
  // Output message to console
  Serial.println("B37VB Demonstration");
  Serial.print("Version: ");
  Serial.println(FIRMWARE_VERSION);

  #if VARIABLE_SPEED_ENABLE
    Serial.println("Variable Motor Speed Enabled");
  #endif
}

// Loop function runs over and over again forever
void loop()
{
  static int LeftMotorPWMValue  = MOTOR_L_PWM_INITIAL_VALUE;
  static int RightMotorPWMValue = MOTOR_R_PWM_INITIAL_VALUE;
  
  UpdateMotorSpeed(LeftMotorPWMValue,
                   RightMotorPWMValue,
                   UPDATE_PERIOD_MS);

  #if VARIABLE_SPEED_ENABLE
    if (LeftMotorPWMValue >= MOTOR_PWM_DECREMENT_VALUE)
    {
      LeftMotorPWMValue  -= MOTOR_PWM_DECREMENT_VALUE;
      RightMotorPWMValue -= MOTOR_PWM_DECREMENT_VALUE;
    }
    else
    {
      LeftMotorPWMValue  = MOTOR_L_PWM_INITIAL_VALUE;
      RightMotorPWMValue = MOTOR_R_PWM_INITIAL_VALUE;
    }
  #endif
}
